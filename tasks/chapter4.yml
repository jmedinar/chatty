# yaml-language-server: $schema=https://schemastore.org/yamllint.json
# Example format and required fields
  # - name: 
  #   description: 
  #   action: 
  #   verification: 
  #   exit_code: 
---
title: Chapter 4
section: Understanding File Attributes
tasks:

  - name: Linux file types
    description: |

      `-` Regular file are those without any imposed structure.
      `d` Directory contains named references to other files.
      `l` Link is a pointer to another file by name.
      `c` Character Device let programs communicate with the hardware.
      `s` Sockets allow processes to communicate locally and over the network.
      `p` Pipes allow communication between two processes over the kernel.
      `b` Block Device allow communication with storage hardware.

    action: |
      The first character of an `ls -l` command's indicates the file type

      List `/dev/` and `/etc/` directories filtering specific file types:

        Look for regular files:          ls -l /dev/ /etc/ | grep ^-

        Look for directories:            ls -l /dev/ /etc/ | grep ^d
        
        Look for symbolic links:         ls -l /dev/ /etc/ | grep ^l
        
        Look for character device files: ls -l /dev/ /etc/ | grep ^c
        
        Look for local domain sockets:   ls -l /dev/ /etc/ | grep ^s

        Look for block device files:     ls -l /dev/ /etc/ | grep ^b
    verification: SKIP_CHECK
    exit_code: 0

  - name: Displaying file statistics and metadata (stat)
    description: |
      The `stat` command displays detailed metadata about a file or directory.
      While `ls -l` shows basic information like permissions and size, `stat`
      provides more in-depth data, including:

      - Inode number
      - Creation, Access, and Modification timestamps
      - Block size and number of blocks
    action: |
      Use the `stat` command to view the metadata for your shell's configuration file.

      stat ~/.bashrc
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using (stat) to filter file attributes and generate specific formats
    description: |
      You can use the `-c` (format) option with `stat` to display specific
      file metadata in a custom format, which is useful for scripting, and
      generating reports.
      
      Here are some common format specifiers:
      
      - `%n`: filename
      - `%s`: total size in bytes
      - `%a`: access permissions in octal mode
      - `%U`: owner name
      - `%G`: group name

      Look at the `--help` option of `stat` to see the full list.
    action: |
      Use `stat` to display just the permissions, size, and filename
      of `/etc/passwd`.

      stat -c "%a %s %n" /etc/passwd
      
      Add some formatting to make it more readable.

      stat -c "MODE: (%a) SIZE: (%s) FILE: (%n)" /etc/passwd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding file ownership and permissions (ls -l)
    description: |
      The `ls -l` command provides a detailed list of file information,
      including a file's permissions, ownership, and group.

      -rwx------. 1 root root 1234 May 12 10:00 filename

      The sections are as follows:

      <filetype> <mode> <links> <owner> <group> <size> <date> <filename>
      
      Here's what each part means:
        - filetype: Represents the file type
        - mode:     File's permissions.
        - links:    Number of hard links
        - owner:    Owner of the file.
        - group:    Group of the file.
        - size:     Size of the file in bytes.
        - date:     Date and time the file was last modified.
        - filename: Name of the file.
      
    action: |
      Use `ls -l` to check the ownership and permissions of a file.

      ls -l /etc/passwd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Changing file ownership
    description: |
      The `chown` (change owner) command changes the user and/or
      group ownership of a file or directory.

      The format is `chown <user>:<group> <file>`.
    action: |
      Create a file and then change its ownership.

      1. Create a file in your home directory:
         touch ~/my_test_file.txt

      2. Use `ls -l` to confirm the file ownership:
         ls -l ~/my_test_file.txt
      
      3. Change its ownership to the `root` user and `root` group:
         sudo chown root:root ~/my_test_file.txt
      
      4. Use `ls -l` to confirm the ownership has changed.
         ls -l ~/my_test_file.txt

      5. Rollback, only the group, and then list:
         sudo chown :$USER ~/my_test_file.txt
         ls -l ~/my_test_file.txt

    verification: ls -l ~/my_test_file.txt | grep -q "root:"
    exit_code: 0

  - name: Changing file permissions using symbolic notation
    description: |
      The `chmod` command (change mode) is used to modify a file's permissions.
      Symbolic notation uses a combination of letters to specify who gets
      what permission.

      Who:              Operator:         Permissions:
        `u` (user)        `+` (add)         `r` (read)
        `g` (group)       `-` (remove)      `w` (write)
        `o` (other)       `=` (set)         `x` (execute)
        `a` (all)  
        
    action: |
      Change the permissions of a file.
        Tip: Verify the permissions using `ls -l` after each change.

      1. Create a new file:
         touch ~/permissions_test.txt
      
      2. Remove all permissions from the file:
         chmod a-rwx ~/permissions_test.txt

      3. Add read, write, and execute permissions back for the user:
         chmod u+rwx ~/permissions_test.txt

      4. Add execute permissions for the group:
         chmod g+x ~/permissions_test.txt

      5. Add read permissions to the others:
         chmod o+r ~/permissions_test.txt

      6. Remove the execute permission from the user:
         chmod u-x ~/permissions_test.txt

      7. Make the permissions `--xrw--w-` in a single command:
         chmod u=x,g=rw,o=w ~/permissions_test.txt

    verification: stat -c %a ~/permissions_test.txt | grep -q 162
    exit_code: 0

  - name: Changing file permissions using octal notation
    description: |
      Octal notation is another way to set file permissions with `chmod`.
      We still represent three personas: user (u), group (g), and others (o)
      But we use numbers to represent permissions for each persona, where:

      read(r) = 4    write(w) = 2   execute(x) = 1

      For example: rwxr-xr-x is `755` in octal notation.
      
      Because:
        rwx for the user equals (4+2+1) = 7
        r-x for the group equals (4+1) = 5
        r-x for others equals (4+1) = 5
    action: |
      Set a file to test using octal notation.
      (Use `ls -l` to confirm the permissions after each change.)

      1. Create a new file:
         touch ~/octal_test.txt

      2. Remove all the permissions:
         chmod 000 ~/octal_test.txt

      3. Add read, write, and execute permissions for the user
         chmod 700 ~/octal_test.txt

      4. Add read permissions for the group:
         chmod 740 ~/octal_test.txt

      5. Add read and execute permissions for others:
         chmod 745 ~/octal_test.txt
    verification: stat -c %a ~/octal_test.txt | grep -q 745
    exit_code: 0

  - name: Understanding special mode (setuid)
    description: |
      The `setuid` (Set User ID) special permission bit is used on executable
      files. When set, it allows a user to run the file with the permissions
      of its owner, typically `root`. The `setuid` bit is represented by 
      an `s` in the owner's execute permission field (e.g., `-rwsr-xr-x`).

      IMPORTANT: For security reasons, `setuid` is not allowed on the shell
      scripts and it's only honored in binary files.
    action: |
      1. Create the file `~/hello.cpp` in your text editor with the following content:
          #include <iostream>
          #include <unistd.h>
          #include <pwd.h>
          int main() {
            uid_t euid = geteuid();
            passwd *p = getpwuid(euid);
            std::cout << "Running as UID: " << euid << " (" << p->pw_name << ")" << std::endl;
            return 0;
          }

      2. Save the file and compile it with the command: `g++ ~/hello.cpp -o ~/hello`
        In case of error run: (sudo dnf install -y gcc-c++)

      3. Run the binary program: 
         ~/hello

      4. Change the ownership to root and rerun it:
         sudo chown root:root ~/hello
         ~/hello

      5. Set the `setuid` and execute one more time:
         sudo chmod u+s ~/hello
         ~/hello
    verification: stat -c %a ~/hello | grep -q 4755
    exit_code: 0

  - name: Understanding special mode (setgid)
    description: |
      The `setgid` (Set Group ID) special permission bit is similar to `setuid`,
      but it applies to directories. When a file is created in a directory
      with the `setgid` bit set, it inherits the group ownership of that
      directory instead of the user's primary group.
      
      The `setgid` is useful for shared directories where all files should belong to
      a single group. 
      
      The `setgid` bit is represented by an `s` in the group's execute permission field
      
          (e.g., `-rwxrw-sr--`).
    action: |
      1. Create a directory and a new group for testing:
         sudo groupadd sharedgroup
         mkdir ~/test-setgid
         ls -ld ~/test-setgid

      2. Try creating a file in the new directory
         touch ~/test-setgid/my-file.txt

      3. Change the group that owns the directory to the new group created
         sudo chown :sharedgroup ~/test-setgid
         ls -ld ~/test-setgid

      4. Set the `setgid` bit on the directory:
         sudo chmod g+s ~/test-setgid
         ls -ld ~/test-setgid

      5. Create a new file in the directory:
         touch ~/test-setgid/shared-file.txt
         ls -l ~/test-setgid/
    verification: stat -c %G ~/test-setgid/shared-file.txt | grep -q sharedgroup
    exit_code: 0

  - name: Understanding special mode (sticky-bit)
    description: |
      The `sticky-bit` is a special permission bit typically used on
      directories with public write permissions. When set, it prevents
      users from deleting or renaming files in that directory unless
      they own the file, are the directory owner, or are `root`.
      
      The bit is represented by a `t` at the end of the permissions
      string (e.g., `drwxrwxrwt`).
    action: |
      Create a temporary shared directory to demonstrate the `sticky-bit`.

      1. As root (sudo) create a new directory and give it global write permissions:
         sudo mkdir /test-sticky
         sudo chmod 1777 /test-sticky
         ls -ld /test-sticky

      2. As your regular user, create a file in that directory. It will work.
         touch /test-sticky/user1.txt

      3. Create a new user "test-user" and switch to it:
         sudo useradd test-user
         sudo su - test-user

      4. As the new user, see if you can create a new file
         touch /test-sticky/user2.txt`
      
      5. Also, as the new user, try deleting the first file. (It would fail)
         rm /test-sticky/user1.txt

      6. Type `exit` to return to your regular user
    verification: stat -c %a /test-sticky | grep -q 1777
    exit_code: 0

  - name: Understanding default permissions (umask)
    description: |
      The `umask` (user mask) command determines the default file
      permissions for new files and directories the user creates.
      It's a security measure that masks out certain permissions.
      
      The `umask` value is a three-digit octal number. The default is typically `0022`.
      To calculate the final permissions, you subtract the `umask` from the
      maximum allowed permissions:
      
      - **Files:** `666` (no execute) - `022` = `644` (`rw-r--r--`)
      - **Directories:** `777` (full access) - `022` = `755` (`rwxr-xr-x`)
    action: |
      Observe your current `umask` and see how it affects a new file.

      1. View your current `umask`:
         umask
      
      2. Create a file and a directory:
           touch ~/umask-test-file.txt
           mkdir ~/umask-test-dir

      3. Use `stat` to compare permissions to your current `umask` value.
           stat -c "%a %n" ~/umask*

      4. Change the umask and create a new set of files
           umask 0000
           touch ~/umask-test-file2.txt
           mkdir ~/umask-test-dir2

      5. Use `stat` again to compare
           stat -c "%a %n" ~/umask*

      6. IMPORTANT: Roll back the change made to the umask
           umask 0022
    verification: SKIP_CHECK
    exit_code: 0

  - name: Making directories
    description: |
      The `mkdir` command is used to create new directories. It is a
      fundamental command for organizing your filesystem.
    action: |
      (see the directory structure with `tree ~/new` after each command)

      1. Create a new directory in your home folder.
         mkdir ~/new
      
      2. Make another directory inside the `new` directory.
         mkdir ~/new/dir1

      3. You can also create multiple directories at once.
         mkdir ~/new/dir2 ~/new/dir3
      
      4. You can also create directories recursively using `-p`.
         mkdir -p ~/new/dir1/dir2/dir3

      5. Use regular expressions to create directories.
         mkdir ~/new/dir{10..20}
      
    verification: ls -ld ~/new
    exit_code: 0

  - name: Making files
    description: |
      The `touch` command is used to create a new, empty file or update
      the timestamp of an existing file.
    action: |
      (see the new files created with `tree ~/new` after each command)

      1. Create a new file in your "new" directory.
         touch ~/new/my_file.txt

      2. Create multiple files at once.
         touch ~/new/file1.txt ~/new/file2.txt

      3. Use regular expressions to create files.
         touch ~/new/file{1..5}.txt

      4. Change the timestamp of an existing file.
         touch ~/new/my_file.txt

    verification: ls ~/new/my_file.txt
    exit_code: 0

  - name: Copying files and directories
    description: |
      The `cp` command is used to copy files and directories. 
      
      The format is:

          cp [source] [destination]
          
      Use the `-r` (recursive) option to copy directories.
    action: |
      Copy the file you just created.

      1. Copy `my_file.txt` to a new file named `my_file_copy.txt`:
         cp ~/new/my_file.txt ~/new/my_file_copy.txt

      2. Copy the directory by using `-r`:
         cp -r ~/new ~/new_copy
    verification: ls -l ~/new/my_file_copy.txt
    exit_code: 0

  - name: Moving and renaming files and directories
    description: |
      The `mv` command is used to move files and directories. When the destination
      uses a new name, it effectively renames the file.

      The format is: 
      
        `mv [source] [destination]`
    action: |
      Rename the file you just copied.

      1. Rename `my_file_copy.txt` to `my_file_renamed.txt`:
         mv ~/new/my_file_copy.txt ~/new/my_file_renamed.txt

      2. Move the renamed file to the other copy of the directory you created.
         mv ~/new/my_file_renamed.txt ~/new_copy/

    verification: ls -l ~/new_copy/my_file_renamed.txt
    exit_code: 0

  - name: Deleting files
    description: |
      The `rm` command (remove) is used to delete files. By default, it
      does not prompt for confirmation. Use with caution!

      WARNING: Deleting files is a permanent action; there is 
               no "trash bin" to recover files deleted in the terminal
    action: |
      Delete the `my_file_renamed.txt`.

      1. Delete the file:
         rm ~/new_copy/my_file_renamed.txt

    verification: ls -l ~/new_copy/my_file_renamed.txt
    exit_code: 1

  - name: Deleting directories
    description: |
      To delete a directory, you must use `rm` with the `-r` (recursive) option,
      deleting the directory and all of its contents.
    action: |
      Delete the `new_directory` you created.

      1. Delete the directory:
         rm -r ~/new_directory

    verification: ls -ld ~/new_directory
    exit_code: 1

  - name: Making symbolic links (soft links)
    description: |
      The `ln` command (link) creates a link to a file. A symbolic link 
      (or soft link) is a file that points to another file or directory
      by its name. The format is 
      
        ln -s [target] [link_name]

      It's a good practice to use full paths when creating symbolic links.

      When the target file is deleted or moved, the link is considered broken.

      A symbolic link can also be used to create a shortcut to a directory.
    action: |
      (use `ls -l *link*` after each command to see the link)

      1. Create a symbolic link to the `/etc/passwd` file in your home directory.
         ln -s /etc/passwd ~/passwd_link

      2. Create a symbolic link to the /tmp directory.
         ln -s /tmp ~/tmp_link

      3. Create a new file to use as target and then create a symbolic link to it.
         touch ~/target_file.txt
         ln -s ~/target_file.txt ~/target_link
        
      4. Delete the target file and observe the effect on the link.
         rm ~/target_file.txt
         ls -l ~/target_link
    verification: ls -l ~/passwd_link | grep -q "/etc/passwd"
    exit_code: 0

  - name: Making hard links
    description: |
      A *hard link* is a pointer to a file's position on the disk. (not to its name)

      - Hard links share the same content and inode number.
      - Deleting a hard link does not delete the target file.
      - Deleting the target file does not delete the hard link.

      "Hard Links are a great way to make backups of files."
    action: |
      Create a file and then make a hard link to it.

      1. Create a file containing the string "Music is life!" and check its inode number (`-i`):
         echo "Music is life!" > ~/my_target_file.txt
         ls -i ~/my_target_file.txt

      2. Create a hard link to the file and check its inode number and content:
         ln ~/my_target_file.txt ~/my_hard_link.txt
         ls -li ~/my_target_file.txt ~/my_hard_link.txt
         more ~/my_target_file.txt ~/my_hard_link.txt

      3. Delete the target file and observe the content on the remaining hard link.
         rm ~/my_target_file.txt
         more ~/my_hard_link.txt

    verification: SKIP_CHECK
    exit_code: 0

  - name: Archiving (tar)
    description: |
      The `tar` command is used to create files and directory archives.

      The format is: tar [options] [source] [destination]
    action: |
      1. Create a test directory:
         mkdir ~/dir1

      2. Create a test file in the directory:
         touch ~/dir1/file1.txt

      3. Create an archive of the file and directory:
         tar -cvf archive.tar dir1/

      4. Create a new file outside the directory:
         touch ~/file2.txt

      5. Add the new file to the archive:
         tar -cvf archive.tar dir1/ file2.txt

      6. List the contents of the archive:
         tar -tf archive.tar

      7. Create a new archive file but with compression
         tar -czvf archive_compressed.tar.gz dir1/ file2.txt

      8. List the two archived files and compare their size.
         du -sh archive*
    verification: ls -l ~/archive.tar.gz
    exit_code: 0

  - name: Unarchive and decompress files (tar)
    description: |
      To unarchive, use `-x` and `-z` to decompress
    action: |
      1. Remove the dir1 directory and the file2.txt:
         rm -rf ~/dir1/ file2.txt

      2. Extract your compressed archive:
         tar -xvzf ~/archive_compressed.tar.gz

      3. Verify that your files are there:
         ls -l ~/dir1/ file2.txt

      4. Extract the archive into a new 'backups' directory:
         mkdir ~/backups
         tar -xvf ~/archive.tar -C ~/backups/
         tree ~/backups/

         The `-C` option specifies the destination directory
    verification: ls ~/unarchive_test | grep -q "file1.txt"
    exit_code: 0

  - name: Compressing (gzip) and Decompressing (gunzip)
    description: |
      The `gzip` command compresses a single file, replacing the original
      with a compressed file ending in `.gz`. `gunzip` decompresses it.
    action: |
      1. Create a test file:                   touch ~/testfile.txt

      2. Compress it with `gzip`:              gzip ~/testfile.txt

      3. Decompress it with `gunzip`:          gunzip ~/testfile.txt.gz
    verification: ls -l ~/testfile.txt
    exit_code: 0

  - name: Compressing (bzip2) and decompressing (bzip2)
    description: |
      The `bzip2` command is another compression utility, similar to `gzip`,
      but it often provides better compression at the cost of being slower.
      It creates files ending in `.bz2`.
    action: |
      1. Create a test file:           touch ~/testfile2.txt

      2. Compress it with `bzip2`:     bzip2 ~/testfile2.txt

      3. Decompress it with `bunzip2`: bunzip2 ~/testfile2.txt.bz2
    verification: ls -l ~/testfile2.txt
    exit_code: 0

  - name: Compressing (zip) and decompressing (zip)
    description: |
      The `zip` command is a popular utility for creating compressed archives
      that can contain multiple files and directories. `unzip` is used for
      extracting them.
    action: |
      1. Create a directory with a few files:
         mkdir ~/zip_test && cd ~/zip_test
         touch file1.txt file2.txt

      2. Create a zip archive:
         zip -r my_archive.zip .

      3. Extract the archive into a new location:
         mkdir ~/unzip_test
         unzip my_archive.zip -d ~/unzip_test
    verification: ls -l ~/unzip_test | grep -q "file1.txt"
    exit_code: 0

  - name: Compressing (xz) and decompressing (xz)
    description: |
      `xz` is a powerful compression utility that uses the LZMA2 algorithm.
      It generally provides the best compression ratio, but is slower than
      `gzip` and `bzip2`. Files compressed with `xz` end with `.xz`.
    action: |
      1. Create a test file:             touch ~/testfile3.txt

      2. Compress it with `xz`:          xz ~/testfile3.txt

      3. Decompress it with `unxz`:      unxz ~/testfile3.txt.xz
    verification: ls -l ~/testfile3.txt
    exit_code: 0

  - name: Synchronizing files (rsync)
    description: |
      The `rsync` command is a versatile tool for synchronizing files and
      directories, locally or remotely. It is highly efficient because it
      only transfers the differences between the source and destination files.
    action: |
      1. Create a local test directory with a file:
         mkdir ~/sync_test
         echo "Hello" > ~/sync_test/file1.txt

      2. Create another directory to synchronize to:
         mkdir ~/sync_backup/

      3. Run `rsync` to synchronize the backup directory:
         rsync -avz ~/sync_test/ ~/sync_backup/

      4. Create a new file in the local directory:
         echo "World" > ~/sync_test/file2.txt

      5. Run `rsync` again to synchronize the backup directory:
         rsync -avz ~/sync_test/ ~/sync_backup/

      6. The same process can be applied to a remote host:
         rsync -avz ~/sync_test/ <user>@<host>:/path/to/remote/dir
    verification: SKIP_CHECK
    exit_code: 0

...