# yaml-language-server: $schema=https://schemastore.org/yamllint.json
# Example format and required fields
  # - name: 
  #   description: 
  #   action: 
  #   verification: 
  #   exit_code: 
---
title: Chapter 5
section: Command Line Text Processing and I/O Redirections
tasks:

  - name: Learning to use the "su" command
    description: |
      The `su` (substitute user) command allows you to switch to another
      user's account. This is a fundamental command for system administration
      and troubleshooting.
      
      When used without an argument, it defaults to switching to the `root`
      user. The `-` (dash) option tells `su` to simulate a full login,
      loading the new user's environment variables and home directory.
    action: |
      1. Use `su -` to switch to the `root` user. You will be prompted for the
         `root` password.
      2. Type `exit` to return to your original user.
      3. Do it again, without the `-` option, to see the difference in environment.
    verification: SKIP_CHECK
    exit_code: 0

  - name: Learning to use the "sudo" command
    description: |
      The `sudo` (substitute user do) command allows an authorized user to
      run a command as `root` without needing to switch to the `root` account.
      This is the safest and most common way to perform administrative tasks.
    action: |
      Let's use `sudo` to run a command that requires `root` privileges.

      1. First, try to read the `/etc/shadow` file without `sudo`. (It will fail).
         `cat /etc/shadow`
      2. Now, run the same command using `sudo`. You'll be prompted for your
         own password.
         `sudo cat /etc/shadow`
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the sudoers file basics
    description: |
      The `sudoers` file, located at `/etc/sudoers`, defines which users
      have permission to use `sudo` and what commands they can run. It is
      crucial for system security and should be edited with care.
      
      The recommended way to edit the `sudoers` file is by using the `visudo`
      command, which checks for syntax errors before saving changes.
    action: |
      1. Open the `sudoers` file using `visudo`:
         `sudo visudo`
      2. Look for lines that define user privileges. For example:
         ```
         root ALL=(ALL:ALL) ALL
         ```
         This line means the `root` user can run any command on any host as any user.
      4. Exit `visudo`:
          - use the key combination `Ctrl+X` if using nano
          - use the key combination `Esc+:+q!` if using vim
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Using the "lslogins", "id", and "who" commands
    description: |
      The `lslogins`, `id`, and `who` commands provide information about users
      and their sessions on the system.
      
      - `lslogins`: Lists information about users.
      - `id`: Displays the user ID (UID) and group ID (GID).
      - `who`: Shows who is currently logged into the system.
    action: |
      1. Run `lslogins` to see a list of all users on the system.
      2. Use `id` to check your own user ID and group ID.
      3. Execute `who` to see who is currently logged in.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/passwd" file
    description: |
      The `/etc/passwd` file contains user account information. Each line
      represents a user and includes fields separated by colons, such as:
      
      username:password placeholder:UID:GID:User Info:Home Directory:Shell
      
      Understanding this file is essential for managing user accounts on a Linux system.
    action: |
      1. Open the `/etc/passwd` file using `view`:`:
         `view /etc/passwd`
      2. Observe the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/shadow" file
    description: |
      The `/etc/shadow` file contains secure user account information, including
      hashed passwords and password aging information. It is only accessible by
      the `root` user for security reasons.
      
      Each line in this file corresponds to a user and includes fields such as:

      username:hashed_password:last_change:min:max:warn:inactive:expire
    action: |
      1. Use `sudo view /etc/shadow` to open the file.
      2. Examine the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/group" file
    description: |
      The `/etc/group` file contains group account information. Each line
      represents a group and includes fields separated by colons, such as:
      
      groupname:password placeholder:GID:user1,user2,...
      
      Understanding this file is essential for managing groups on a Linux system.
    action: |
      1. Open the `/etc/group` file using `view`:
         `view /etc/group`
      2. Observe the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Creating users "useradd"
    description: |
      The `useradd` command is used to create new user accounts on a Linux system.
      It allows you to specify various options such as the user's home directory,
      shell, and group memberships.

      See all available options with: `useradd --help`
    action: |
      1. Use the following command to create a new user:
         `sudo useradd -s /bin/bash user1`
         This creates a user named `user1` and sets the default shell to bash.
      2. Create "user2" specifying a home directory, shell, user ID, and info:
         `sudo useradd -d /home/user2 -s /bin/bash -u 10002 -c "User Two" user2`
      3. Verify the creation of the users by checking the `/etc/passwd` file:
         `cat /etc/passwd | grep user1`
         `cat /etc/passwd | grep user2`
    verification: id user1 2> /dev/null
    exit_code: 0
  
  - name: Modifying users "usermod" 
    description: |
      The `usermod` command is used to modify existing user accounts. You can change
      a user's home directory, shell, group memberships, and more.

      See all available options with: `usermod --help`
    action: |
      1. Change the info of `user1` to `"User One"`:
        `sudo usermod -c "User One" user1`
      2. Add `user1` to the `wheel` group:
        `sudo usermod -aG wheel user1`
      3. Verify by checking the `/etc/passwd` and `/etc/group` files:
         grep user1 /etc/passwd /etc/group
    verification: sudo userdbctl user user1 2> /dev/null | grep -q wheel
    exit_code: 0
  
  - name: Deleting users "userdel"
    description: |
      The `userdel` command is used to delete user accounts from the system.
      You can remove a user and optionally their home directory and files.

      See all available options with: `userdel --help`
    action: |
      1. Delete `user2` and its home directory:
         `sudo userdel -r user2`
      2. Verify the deletion by checking the `/etc/passwd` file:
         `cat /etc/passwd | grep user2`
      3. Ensure the home directory is removed:
         `ls /home | grep user2`
    verification: ! grep -q user2 /etc/passwd
    exit_code: 0
  
  - name: Creating groups "groupadd"
    description: |
      The `groupadd` command is used to create new groups on a Linux system.
      Groups are essential for managing permissions and access control.

      See all available options with: `groupadd --help`
    action: |
      1. Create a new group named `developers`:
         `sudo groupadd developers`
      2. Verify the creation of the group by checking the `/etc/group` file:
         `grep developers /etc/group`
    verification: grep -q developers /etc/group
    exit_code: 0
  
  - name: Modifying groups "groupmod"
    description: |
      The `groupmod` command is used to modify existing groups. You can change
      a group's name, GID, and other attributes.

      See all available options with: `groupmod --help`
    action: |
      1. Change the name of the `developers` group to `devs`:
         `sudo groupmod -n devs developers`
      2. Verify the change by checking the `/etc/group` file:
         `grep devs /etc/group`
    verification: grep -q devs /etc/group
    exit_code: 0

  - name: Adding users to groups "usermod -aG"
    description: |
      The `usermod -aG` command is used to add a user to one or more groups
      without removing them from their current groups. This is useful for granting
      additional permissions to users.
    action: |
      1. Add `user1` to the `devs` group:
         `sudo usermod -aG devs user1`
      2. Verify the addition by checking the `/etc/group` file:
         `grep devs /etc/group`
      3. Check the groups of `user1`:
         `groups user1`
    verification: groups user1 | grep -q devs
    exit_code: 0
  
  - name: Deleting groups "groupdel"
    description: |
      The `groupdel` command is used to delete groups from the system. It removes
      the group entry from the `/etc/group` file.

      See all available options with: `groupdel --help`
    action: |
      1. Delete the `devs` group:
         `sudo groupdel devs`
      2. Verify the deletion by checking the `/etc/group` file:
         `grep devs /etc/group`
    verification: ! grep -q devs /etc/group
    exit_code: 0
  
  - name: Setting user passwords "passwd"
    description: |
      The `passwd` command is used to set or change a user's password.

      Only the user themselves or the `root` user can change a user's password.

      When changing your own user's password, you will be prompted to enter
      the current password followed by the new password twice for confirmation.
    action: |
      1. Change the password for `user1`:
         `sudo passwd user1`
         You will be prompted to enter a new password and confirm it.
      2. Verify the password change by logging in as `user1`:
         `su - user1`
         Enter the new password when prompted.
      3. Exit back to your original user:
         `exit`
    verification: sudo userdbctl user user1 2> /dev/null | grep Passwords | grep -q "1"
    exit_code: 0
  
  - name: Controlling password aging "chage"
    description: |
      The `chage` command is used to control password aging for user accounts.
      It allows you to set when a password must be changed, how long it can be
      used, and when the account will expire.

      The most common options are:
      - `-M`: Maximum number of days a password is valid.
      - `-m`: Minimum number of days between password changes.
      - `-W`: Number of days before password expiration to warn the user.
      - `-I`: Number of days after password expiration until the account is disabled.
      - `-E`: Expiration date of the account.
    action: |
      1. Set password aging for `user1`:
         `sudo chage -M 90 -m 7 -W 14 user1`
         This sets the maximum age to 90 days, minimum age to 7 days, 
         and warning period to 14 days.
      2. Verify the settings by running:
         `sudo chage -l user1`
    verification: sudo chage -l user1 | grep "Maximum" | grep -q "90"
    exit_code: 0
  
  - name: Environment configuration files
    description: |
      Environment configuration files are used to set system-wide or user-specific
      environment variables and shell settings. 
      
      System-wide files include:
      - `/etc/environment`: Sets system-wide environment variables.
      - `/etc/profile`: Configures the shell environment for all users.

      User-specific files include: (notice they are located in the user's home directory)
      - `~/.bashrc`: Configures the shell environment for interactive non-login shells.
      - `~/.profile`: Configures the shell environment for login shells, used by some distributions.
      
      These files can be edited to customize the shell environment.
    action: |
      1. Open the `~/.bashrc` file in your preferred text editor:
         `nano ~/.bashrc`
      2. Add or modify environment variables, aliases, or functions as needed.
         For example, we will make an alias for the `ls -l` command so that it
         call the `ll` command it will print the output in a long listing format:

          ```
          alias ll='ls -l'
          ```
      3. Save and exit the editor.
      4. To apply the changes, open a new terminal or run:
         `source ~/.bashrc`
      5. Test the alias by running `ll` in the terminal.
    verification: grep -qw ll ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Environment variables
    description: |
      Environment variables are dynamic values that affect the behavior of processes
      on a system. They can be set system-wide or user-specific and are used to
      configure various aspects of the shell and applications.
      
      Common environment variables include:
      - `PATH`: Specifies directories to search for executable files.
      - `HOME`: The user's home directory.
      - `USER`: The current user's username.
    action: |
      1. To view your current environment variables, run:
         `printenv`
      2. To set a new environment variable, use:
         `export FRUIT="apples"`
         (To make it persistent, add it to your `~/.bashrc` file.)
      3. Verify the variable is set by running:
         `echo $FRUIT`
    verification: grep -qw FRUIT ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Shell variables
    description: |
      Shell variables are similar to environment variables but are specific to the
      current shell session. They can be used to store temporary values or settings
      that do not need to persist across sessions.
      
      Common shell variables include:
      - `$PS1`: The primary prompt string.
      - `$PS2`: The secondary prompt string.
      - `$PWD`: The current working directory.
    action: |
      1. To view your current shell variables, run:
         `set`
      2. To set a new shell variable, use:
         `FRUIT="banana"`
          (To make it persistent, add it to your `~/.bashrc` file)
      3. Verify the variable is set by running:
         `echo $FRUIT`
    verification: test "$(echo $FRUIT)" = "banana"
    exit_code: 0
  
  - name: Reconfigure your shell prompt
    description: |
      The shell prompt can be customized to display various information such as
      the current user, hostname, and working directory. This is done by modifying
      the `PS1` variable in your shell configuration file (e.g., `~/.bashrc`).
      
      A common format for `PS1` is:
      ```
      PS1='\u@\h:\w\$ '
      ```
      This displays the username, hostname, and current working directory.
    action: |
      1. We will temporarily change the shell prompt to include the current time.

         export PS1='\t \u@\h:\w\$ '

         This will show the time in HH:MM:SS format before the prompt.

      2. Let's add color and icons to the prompt for better visibility.
         We will use the `\[\e[0;32m\]` for green text and `\[\e[0m\]` to reset color.

         export PS1='\[\e[0;32m\]\u@\h:\w\[\e[0m\]\$ '

      3. Now let's put some icons in the prompt.
         We will use `\[\e[0;34m\]` for blue text and add a star icon.

         export PS1='\[\e[0;34m\]â˜… \u@\h:\w\[\e[0m\]\$ '         
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Reconfigure your default editor
    description: |
      The default editor can be set to your preferred text editor, such as `nano`,
      `vim`, or `emacs`. This is useful for editing configuration files and other
      text files from the command line.
      
      The default editor is usually set using the `EDITOR` environment variable.
    action: |
      1. Verify your current default editor by running:
         `echo $EDITOR`
      2. Set your default editor to `nano` by running:
         `export EDITOR=nano`
      3. To make this change persistent, add it to your `~/.bashrc` file
    verification: grep -qw "export EDITOR=nano" ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Reconfigure your history size
    description: |
      The history size is the number of commands you can store in the command history.
      You can configure the history size by setting the `HISTSIZE` and `HISTFILESIZE`
      environment variables in your shell configuration file (e.g., `~/.bashrc`).
    action: |
      1. Check your current history size by running:
         `echo $HISTSIZE`
      2. Set the history size to 1000 by running:
         `export HISTSIZE=10000`
      3. Set the history file size to 2000 by running:
         `export HISTFILESIZE=20000`
      4. To make these changes persistent, add them to your `~/.bashrc` file:
         ```
         echo "export HISTSIZE=10000" >> ~/.bashrc
         echo "export HISTFILESIZE=20000" >> ~/.bashrc
         ```
    verification: grep -qw "HIST" ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Reconfigure your path
    description: |
      The `PATH` environment variable specifies the directories where the shell
      looks for executable files. You can add directories to your `PATH` to
      make custom scripts or programs easily accessible from the command line.
      
      The `PATH` variable is a colon-separated list of directories.
    action: |
      1. Check your current `PATH` by running:
            echo $PATH
      2. Let's add a new "scripts" directory in your home Directory:
            mkdir -p ~/scripts
      3. Create a sample script in this directory with the following content:
            #!/bin/bash
            echo Hello from your script!
      4. Save it as `myhello` in the `~/scripts` directory, and make it executable:
            chmod +x ~/scripts/myhello 
      5. From your home directory, try running the script by name:
            myhello
        (It will fail because the directory is not in your `PATH` yet)
      6. Add this directory to your `PATH` by running:
            export PATH=$PATH:~/scripts
      7. Now try running the script again:
            myhello
      8. To make this change persistent, add it to your `~/.bashrc` file:
         echo "export PATH=\$PATH:~/scripts" >> ~/.bashrc
      
      From now on, any new script you place in the `~/scripts` directory
      will be executable from anywhere in the system.
    verification: 
    exit_code: 0
  
...