# yaml-language-server: $schema=https://schemastore.org/yamllint.json
# Example format and required fields
  # - name: 
  #   description: 
  #   action: 
  #   verification: 
  #   exit_code: 
---
title: Chapter 5
section: Command Line Text Processing and I/O Redirections
tasks:

  - name: Learning to use the "su" command
    description: |
      The `su` (substitute user) command allows you to switch to another
      user's account. 
      
      When used without an argument, it defaults to switching to the `root`
      user. The `-` (dash) option tells `su` to simulate a complete login,
      loading the new user's environment variables and home directory.
    action: |
      1. Use `su -` to switch to the `root` user. You will be prompted for the
         `root` password.
      2. Type `exit` to return to your original user.
      3. Do it again, without the `-` option, to see the difference in environment.
    verification: SKIP_CHECK
    exit_code: 0

  - name: Learning to use the "sudo" command
    description: |
      The `sudo` (substitute user do) command allows an authorized user to
      run a command as `root` without switching to the `root` account.
    action: |
      Use `sudo` to run a command that requires `root` privileges.

      1. First, try to read the `/etc/shadow` file without `sudo`. (It will fail).
         cat /etc/shadow

      2. Run the same command using `sudo`. You'll be prompted for your
         own password.
         sudo cat /etc/shadow
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the sudoers file basics
    description: |
      The `sudoers` file, located at `/etc/sudoers`, defines which users
      have permission to use `sudo` and what commands they can run. It is
      crucial for system security and should be edited with care.
      
      The recommended way to edit the `sudoers` file is by using the `visudo`
      command, which checks for syntax errors before saving changes.
    action: |
      1. Open the `sudoers` file using `visudo`:
         sudo visudo

      2. Look for lines that define user privileges. For example:
         
         root ALL=(ALL:ALL) ALL
         
         Meaning:
         (`root` can run any commands on any host as any user)

      4. Exit `visudo`:
          - Use the key combination `Ctrl+X` if using nano
          - Use the key combination `Esc+:+q!` if using vim
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Using the "lslogins", "id", and "who" commands
    description: |
      The `lslogins`, `id`, and `who` commands provide information about users
      and their sessions on the system.
      
      - `lslogins`: Lists information about users.
      - `id`:       Displays the user ID (UID) and group ID (GID).
      - `who`:      Shows who is currently logged into the system.
    action: |
      1. Run `lslogins` to see a list of all users on the system.
      2. Use `id` to check your own user ID and group ID.
      3. Execute `who` to see who is currently logged in.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/passwd" file
    description: |
      The `/etc/passwd` file contains user account information. Each line
      represents a user and includes fields separated by colons, such as:
      
      username:password placeholder:UID:GID:User Info:Home Directory:Shell
      
      Understanding this file is essential for managing user accounts on a Linux system.
    action: |
      1. Open the `/etc/passwd` file using `view`:
            view /etc/passwd

      2. Observe the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/shadow" file
    description: |
      The `/etc/shadow` file contains secure user account information, including
      hashed passwords and password aging information. It is only accessible by
      the `root` user for security reasons.
      
      Each line in this file corresponds to a user and includes fields such as:

      username:hashed_password:last_change:min:max:warn:inactive:expire
    action: |
      1. Use `sudo view /etc/shadow` to open the file.
      2. Examine the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Exploring "/etc/group" file
    description: |
      The `/etc/group` file contains group account information. Each line
      represents a group and includes fields separated by colons, such as:
      
      groupname:password placeholder:GID:user1,user2,...
      
      Understanding this file is essential for managing groups on a Linux system.
    action: |
      1. Open the `/etc/group` file using `view`:
            view /etc/group

      2. Observe the structure of each line and the fields it contains.
      3. Exit the viewer by using the key combination `Esc+:+q`.
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Creating users "useradd"
    description: |
      The `useradd` command creates new user accounts on a Linux system.

      It allows you to specify various options, such as the user's home
      directory, shell, and group memberships.

      See all available options with: `useradd --help`
    action: |
      1. Use the following command to create a new user:
              sudo useradd -s /bin/bash user1

         Creates a user named `user1` and sets the default shell to bash.

      2. Create "user2" specifying a home directory, shell, user ID, and info:
         sudo useradd -d /home/user2 -s /bin/bash -u 10002 -c "User Two" user2

      3. Verify the creation of the users by checking the `/etc/passwd` file:
         cat /etc/passwd | grep user1
         cat /etc/passwd | grep user2
    verification: id user1 2> /dev/null
    exit_code: 0
  
  - name: Modifying users "usermod" 
    description: |
      The `usermod` command is used to modify existing user accounts. You can change
      a user's home directory, shell, group memberships, and more.

      See all available options with: `usermod --help`
    action: |
      1. Change the info of `user1` to `"User One"`:
          sudo usermod -c "User One" user1

      2. Add `user1` to the `wheel` group:
          sudo usermod -aG wheel user1

      3. Verify by checking the `/etc/passwd` and `/etc/group` files:
          grep user1 /etc/passwd /etc/group
    verification: sudo userdbctl user user1 2> /dev/null | grep -q wheel
    exit_code: 0
  
  - name: Deleting users "userdel"
    description: |
      The `userdel` command deletes user accounts from the system.

      You can optionally delete the home directory and files.

      See all available options with: `userdel --help`
    action: |
      1. Delete `user2` and its home directory:
          sudo userdel -r user2

      2. Verify the deletion by checking the `/etc/passwd` file:
          cat /etc/passwd | grep user2

      3. Ensure the home directory is removed:
          ls /home | grep user2
    verification: ! grep -q user2 /etc/passwd
    exit_code: 0
  
  - name: Creating groups "groupadd"
    description: |
      The `groupadd` command creates new groups on a Linux system.

      See all available options with: `groupadd --help`
    action: |
      1. Create a new group named `developers`:
          sudo groupadd developers

      2. Verify the creation of the group by checking the `/etc/group` file:
          grep developers /etc/group
    verification: grep -q developers /etc/group
    exit_code: 0
  
  - name: Modifying groups "groupmod"
    description: |
      The `groupmod` command modifies existing groups. You can change
      a group's name, GID, and other attributes.

      See all available options with: `groupmod --help`
    action: |
      1. Change the name of the `developers` group to `devs`:
          sudo groupmod -n devs developers

      2. Verify the change by checking the `/etc/group` file:
          grep devs /etc/group
    verification: grep -q devs /etc/group
    exit_code: 0

  - name: Adding users to groups "usermod -aG"
    description: |
      The `usermod -aG` command adds users to one or more groups
      without removing them from their current groups.
    action: |
      1. Add `user1` to the `devs` group:
          sudo usermod -aG devs user1

      2. Verify the addition by checking the `/etc/group` file:
          grep devs /etc/group

      3. Check the groups of `user1`:
          groups user1
    verification: groups user1 | grep -q devs
    exit_code: 0
  
  - name: Deleting groups "groupdel"
    description: |
      The `groupdel` command deletes groups from the system.

      See all available options with: `groupdel --help`
    action: |
      1. Delete the `devs` group:
          sudo groupdel devs

      2. Verify the deletion by checking the `/etc/group` file:
          grep devs /etc/group
    verification: ! grep -q devs /etc/group
    exit_code: 0
  
  - name: Setting user passwords "passwd"
    description: |
      The `passwd` command sets or changes a user's password.

      Only the user themselves or the `root` user can change a user's password.

      When changing your user's password, you will be prompted to enter
      the current password, followed by the new password twice for confirmation.
    action: |
      1. Change the password for `user1`:
          sudo passwd user1

         You will be prompted to enter a new password and confirm it.

      2. Verify the password change by logging in as `user1`:
          su - user1

         Enter the new password when prompted.

      3. Exit back to your original user:
          exit
    verification: sudo userdbctl user user1 2> /dev/null | grep Passwords | grep -q "1"
    exit_code: 0
  
  - name: Controlling password aging "chage"
    description: |
      The `chage` command controls password aging for user accounts.

      Allows you to set when a password must be changed, how long it can be
      used, and when the account will expire.

      The most common options are:
      - `-M`: Maximum number of days a password is valid.
      - `-m`: Minimum number of days between password changes.
      - `-W`: Number of days before password expiration to warn the user.
      - `-I`: Number of days after password expiration until the account is disabled.
      - `-E`: Expiration date of the account.
    action: |
      1. Set password aging for `user1`:
          sudo chage -M 90 -m 7 -W 14 user1

         Sets the maximum age to 90 days, minimum age to 7 days, 
         and a warning period to 14 days.

      2. Verify the settings by running:
          sudo chage -l user1
    verification: sudo chage -l user1 | grep "Maximum" | grep -q "90"
    exit_code: 0
  
  - name: Environment configuration files
    description: |
      Environment configuration files set system-wide or user-specific
      environment variables and shell settings. 
      
      System-wide files include:
      - `/etc/environment`: Sets system-wide environment variables.
      - `/etc/profile`: Configures the shell environment for all users.

      User-specific file: (located in the user's home directory)
      - `~/.bashrc`: Configures the shell environment.
    action: |
      1. Open the `~/.bashrc` file in your preferred text editor:
            nano ~/.bashrc

      2. Add or modify environment variables, aliases, or functions.
         For example, make alias `ll` for the `ls -l` command:

          alias ll='ls -l'

      3. Save and exit the editor.

      4. To apply the changes, open a new terminal or run:
          source ~/.bashrc

      5. Test the alias by running `ll` in the terminal.
    verification: grep -qw ll ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Environment variables
    description: |
      Environment variables are dynamic values that affect the behavior of processes
      on a system. They can be set system-wide or user-specific and are used to
      configure various aspects of the shell and applications.
      
      Common environment variables include:
      - `PATH`: Specifies directories that can search for executable files.
      - `HOME`: The user's home directory.
      - `USER`: The current user's username.
    action: |
      1. To view your current environment variables, run:
          printenv

      2. To set a new environment variable, use:
          export FRUIT="apples"

         (Add it to your `~/.bashrc` file to make it persistent.)

      3. Verify the variable is set by running:
          echo $FRUIT
    verification: grep -qw FRUIT ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Shell variables
    description: |
      Shell variables are similar to environment variables but are specific to the
      current shell session. They can store temporary values or settings that do 
      not need to persist across sessions.
      
      Common shell variables include:
      - `$PS1`: The primary prompt string.
      - `$PS2`: The secondary prompt string.
      - `$PWD`: The current working directory.
    action: |
      1. To view your current shell variables, run:
          set

      2. To set a new shell variable, use:
          FRUIT="banana"

          (To make it persistent, add it to your `~/.bashrc` file)

      3. Verify the variable is set by running:
          echo $FRUIT
    verification: test "$(echo $FRUIT)" = "banana"
    exit_code: 0
  
  - name: Reconfigure your shell prompt
    description: |
      Customize your prompt to display information such as the current user,
      hostname, and working directory, by modifying the `PS1` variable
      
      A common format for `PS1` is:      PS1='\u@\h:\w\$ '

      Displays the username, hostname, and current working directory.
    action: |
      1. We will temporarily change the shell prompt to include the current time.

         export PS1='\t \u@\h:\w\$ '

         Will show the time in HH:MM:SS format before the prompt.

      2. Add color and icons to the prompt for better visibility.
         We will use the `\[\e[0;32m\]` for green text and `\[\e[0m\]` to reset color.

         export PS1='\[\e[0;32m\]\u@\h:\w\[\e[0m\]\$ '

      3. Put some icons in the prompt.
         We will use `\[\e[0;34m\]` for blue text and add a star icon.

         export PS1='\[\e[0;34m\]★ \u@\h:\w\[\e[0m\]\$ '         
    verification: SKIP_CHECK
    exit_code: 0
  
  - name: Reconfigure your default editor
    description: |
      The default editor can be set to your preferred text editor, such as `nano`,
      `vim`, or `gnome-text-editor`. 
      
      The default editor is usually set using the `EDITOR` environment variable.
    action: |
      1. Verify your current default editor by running:
          echo $EDITOR

      2. Set your default editor to `nano` by running:
          export EDITOR=nano

      3. To make it persistent, add it to your `~/.bashrc` file
    verification: grep -qw "export EDITOR=nano" ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Reconfigure your history size
    description: |
      The history size is the number of commands you can store in the command history.
      You can configure the history size by setting the `HISTSIZE` and `HISTFILESIZE`
      environment variables in your shell configuration file (e.g., `~/.bashrc`).
    action: |
      1. Check your current history size by running:
         echo $HISTSIZE

      2. Set the history size to 1000 by running:
         export HISTSIZE=10000

      3. Set the history file size to 2000 by running:
         export HISTFILESIZE=20000

      4. To make these changes persistent, add them to your `~/.bashrc` file:
         echo "export HISTSIZE=10000" >> ~/.bashrc
         echo "export HISTFILESIZE=20000" >> ~/.bashrc
         
    verification: grep -qw "HIST" ~/.bashrc 2> /dev/null
    exit_code: 0
  
  - name: Reconfigure your path
    description: |
      The `PATH` environment variable specifies the directories where the shell
      looks for executable files. You can add directories to your `PATH` to
      make custom scripts or programs easily accessible from the command line.
      
      The `PATH` variable is a colon-separated list of directories.
    action: |
      1. Check your current `PATH` by running:
            echo $PATH
      2. Add a new "scripts" directory in your home Directory:
            mkdir -p ~/scripts
      3. Create a script in the `~/scripts` directory
           vim ~/scripts/myhello
      4. Add the following content to the script
            #!/bin/bash
            echo Hello from your script!
      5. Save it, and make it executable:
            chmod +x ~/scripts/myhello 
      5. From your home directory, try running the script by name:
            myhello
        (It will fail because the directory is not in your `PATH` yet)
      6. Add this directory to your `PATH` by running:
            export PATH=$PATH:~/scripts
      7. Try running the script again:
            myhello
      8. To make it persistent, add it to your `~/.bashrc` file:
         echo "export PATH=\$PATH:~/scripts" >> ~/.bashrc
      
      New scripts in the `~/scripts` directory will be system-wide reachable.
    verification: SKIP_CHECK
    exit_code: 0
  
...