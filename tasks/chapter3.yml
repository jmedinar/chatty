# yaml-language-server: $schema=https://schemastore.org/yamllint.json
# Example format and required fields
  # - name: 
  #   description: 
  #   action: 
  #   verification: 
  #   exit_code: 
---
title: Chapter 3
section: Command Line Text Processing and I/O Redirection
tasks:

  - name: Using the grep command
    description: |
      The `grep` command (Global Regular Expression Print) is essential for
      searching plain-text data sets for lines that match a regular expression.
      
      It is most often used to filter the output of other commands.
    action: |
      Use `grep` to find lines containing "root" in the `/etc/passwd` file.
      
          grep root /etc/passwd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using grep ignoring case sensitivity
    description: |
      The `-i` option allows `grep` to ignore case when searching for patterns.
    action: |
      Use `grep` with the `-i` option to find lines containing "root" in the
      `/etc/ssh/sshd_config` file, ignoring case.
      
          grep -i root /etc/ssh/sshd_config
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using grep inverting the match
    description: |
      The `-v` option inverts (reverse) the match, showing lines that do not match the
      specified pattern, filtering out unwanted lines.
    action: |
      Use `grep -v` to find lines in the `/etc/passwd` file that do not contain
      the "nologin" shell.
      
          grep -v nologin /etc/passwd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using grep with regular expressions
    description: |
      `grep` supports regular expressions, allowing for complex pattern matching.
      
      We will explore more regular expression features in later chapters, but for now,
      explore some basic regex patterns with `grep`.
    action: |
      Find lines in the `/etc/passwd` file that:
        1. Contain a username starting with "a" followed by any characters.
            grep "^a.*" /etc/passwd
        2. Contain a username ending with "d" followed by any characters.
            grep ".*d$" /etc/passwd
        3. Contain a username with exactly three characters.
            grep "^...$" /etc/passwd
        4. Contain a username with "a" as the second character.
            grep "^.a.*" /etc/passwd
        5. Contain a username with "a" as the second-to-last character.
            grep "^.*a.$" /etc/passwd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using other common grep options
    description: |
      `grep` has many other useful options. Here are a few common ones:
      
      - `-c`: Count the number of matching lines.
      - `-n`: Show line numbers with output lines.
      - `-l`: List only the names of files with matching lines.
    action: |
     Explore their functionality.
          grep -c root /etc/passwd
          grep -n root /etc/passwd
          grep -l root /etc/*
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using grep to parse command output
    description: |
      The command `grep` can filter the output of other commands, narrowing
      down results from commands that produce large amounts of output to 
      focus on specific information.
      
    action: |
      We will filter the free command to get only the total memory information.

          free -h | grep "Mem" | awk '{print $2}'

          (We extracted the second column from the output.)

      Use `grep` to parse the output of the `df -h` command to find available 
      disk space on the root filesystem "/" and print only the fourth column.

          df -h | grep "/$" | awk '{print $4}'

    verification: SKIP_CHECK
    exit_code: 0

  - name: Using grep with multiple files
    description: |
      `grep` can search multiple files simultaneously, finding patterns
      across different files or directories.
    action: |
      Use `grep` to search for the term "root" in all files in the `/etc` directory.

          grep root /etc/*

      Add `-r` to search the `/etc` directory and subdirectories.

          grep release -r /etc/*

    verification: SKIP_CHECK
    exit_code: 0

  - name: Command line expansions - The full stop (`.`)
    description: |
      The full stop (`.`) is a special character to refer to the current directory.

      I like to call it "here".
      
      Use `.` with `ls` to list files in the current directory:
          ls .
    action: |
      Make a copy of the `/etc/passwd` file to the current directory using the `.` character.
      
          cp /etc/passwd .

      Repeat the copy operation renaming the file to `my_passwd.txt`:
      
          cp /etc/passwd ./my_passwd.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Command line expansions - The tilde (`~`)
    description: |
      The tilde (`~`) character in the command line represents the home directory
      of the current user. It is often used to quickly specify paths relative
      to the home directory.
    action: |
      Use the tilde (`~`) to copy the `/etc/motd` file to your home directory.
          cp /etc/motd ~/motd.txt

      Create a new file in your home directory using the tilde (`~`)
          touch ~/my_first_file.txt
    verification: ls -l ~/my_first_file.txt
    exit_code: 0

  - name: Command line expansions - The double dot (`..`)
    description: |
      The double dot (`..`) character in the command line represents the parent
      directory relative to the current directory.
      
      Use `..` with `cd` to change to the parent directory:
          cd ..

      Use `..` with commands to target the parent directory:
          ls ..
    action: |
      At your home, create a new directory named `test_dir`, and navigate into it.

          mkdir ~/test_dir
          cd ~/test_dir

      Copy the `/etc/resolv.conf` file to your home directory using `..`
      
          cp /etc/resolv.conf ../resolv.conf

      List the file `resolv.conf` in the parent directory, along with the 
      `test_dir` (current directory).

        ls -l ../resolv.conf .

      The `resolv.conf` copy is now in your home directory, while the `test_dir`
      directory remains empty.
      
    verification: ls -l ~/resolv.conf
    exit_code: 0

  - name: Wildcards - The asterisk (`*`)
    description: |
      The asterisk (`*`) is a wildcard character that matches zero or more characters.
      
    action: |
      Use `*` with `ls` to list all files in the /etc directory:

          ls * /etc

      Use it to list only txt files:

          ls *.txt /etc

      Use it to list only files with the pattern `conf` somewhere in the name:

          ls *conf* /etc
    verification: SKIP_CHECK
    exit_code: 0

  - name: Wildcards - The question mark (`?`)
    description: |
      The question mark (`?`) is a wildcard character that matches exactly one character.
    action: |
      Use `?` with `ls` to list files and directories in the `/etc` directory 
      that have exactly three characters in their names:

          ls -ld /etc/???
      
      Use it to list files and directories in the /dev directory that have 
      exactly two characters in their names:

          ls -ld /dev/??

    verification: SKIP_CHECK
    exit_code: 0

  - name: Wildcards - The start (`^`) and end (`$`) anchors
    description: |
      The start (`^`) and end (`$`) anchors are used in regular expressions to match
      the beginning and end of a line, respectively.
      
      For example, `^abc` matches lines that start with "abc", and `xyz$` matches lines
      that end with "xyz".
    action: |
      Use `^` to find lines in the `/etc/passwd` file that start with "root":
          grep "^root" /etc/passwd

      Use `$` to find lines in the `/etc/passwd` file that end with "nologin":
          grep "nologin$" /etc/passwd

      Use `^` and `$` to remove empty and commented lines from the `/etc/ssh/sshd_config`.
          sudo grep -vE '^#|^$' /etc/ssh/sshd_config
    verification: SKIP_CHECK
    exit_code: 0

  - name: Pattern matching - The square brackets (`[]`)
    description: |
      Square brackets (`[]`) are used in regular expressions to specify
      a character class, which matches any single character within the 
      brackets, matching specific character sets.
      
      For example, `[aeiou]` matches any vowel, and `[0-9]` any digit.
    action: |
      Find lines in the `/etc/passwd` file with a vowel as the second character:

          grep "^.[aeiou]" /etc/passwd

      Find lines in the output of the `df -h` command with two or more 
      digits in the `Use%`` column:

          df -h | grep "[0-9][0-9]%"

      (Only the Use% column makes use of the '%' character.)
    verification: SKIP_CHECK
    exit_code: 0
    
  - name: Pattern matching - The POSIX character classes
    description: |
      POSIX character classes are a set of predefined character classes that can be used
      in regular expressions to match specific types of characters.

      Some common POSIX character classes include:

      - `[[:alpha:]]`: Matches any alphabetic character (a-z, A-Z).
      - `[[:digit:]]`: Matches any digit (0-9).
      - `[[:alnum:]]`: Matches any alphanumeric character (a-z, A-Z, 0-9).
      - `[[:space:]]`: Matches any whitespace character (space, tab, newline).
      - `[[:punct:]]`: Matches any punctuation character.
      - `[[:lower:]]`: Matches any lowercase letter (a-z).
      - `[[:upper:]]`: Matches any uppercase letter (A-Z).
      
    action: |
      Use POSIX character classes to find lines in the `/etc/passwd` file that contain
      a username with at least one alphabetic character:

          grep "[[:alpha:]]" /etc/passwd

      Use POSIX character classes to find lines in the `/etc/passwd` file that contain
      a username with at least one digit:

          grep "[[:digit:]]" /etc/passwd

      Use POSIX character classes to find lines in the `/etc/passwd` file that contain
      a username with at least one uppercase letter:
          
          grep "[[:upper:]]" /etc/passwd

    verification: SKIP_CHECK
    exit_code: 0

  - name: Command line expansions - Creating files using ranges
    description: |
      The command line allows you to create files using ranges, which can be useful for
      generating multiple files with similar names or patterns.
      
      For example, you can use `{}` to create multiple files with a common prefix:

          touch file{1..5}.txt
    action: |
      Create a hundred files named `test`, with the 'txt' extension, in your home directory
      using the range expansion feature.
      
          touch ~/test{1..100}.txt

      Verify that the files were created successfully.
      
          ls -l ~/test*.txt

      Delete the files from 1 to 50 using the range expansion feature again.
      
          rm ~/test{1..50}.txt

      Verify that the files were deleted successfully.
      
          ls -l ~/test*.txt

      Delete the remaining files using a wildcard pattern.
      
          rm ~/test*.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding pipes
    description: |
      The pipe (`|`) allows you to connect the output of one command to 
      the input of another command, helping perform complex operations on data.

      For example, you can use `|` to filter the output of a command using `grep`:

          ls -l | grep "txt"

      The above example lists files, then filters txt files using `grep`.
    action: |
      Use `grep` to parse "nologin" lines in the `/etc/passwd` file.

          grep nologin /etc/passwd

      Narrow down the results by piping again to `grep` and filtering
      lines that contain the "var" pattern.
      
          grep nologin /etc/passwd | grep var

      Pipe one more time to `wc -l` to count the number of lines:

          grep nologin /etc/passwd | grep var | wc -l
    verification: SKIP_CHECK
    exit_code: 

  - name: Understanding output redirection
    description: |
      Redirection allows you to control where the output of a command goes.
      
      You can redirect to a file, overwrite it, or appending to it.
      
      Use `>` to redirect overwriting
          ls -l > output1.txt

      Use `>>` to redirect appending
          ls -l >> output2.txt

    action: |
      Use `grep` to find "root" in the `/etc/passwd` file and redirect
      the output to a file named `~/root_users.txt`.

          grep root /etc/passwd > ~/root_users.txt

      Verify the results stored in the file.

          cat ~/root_users.txt

      Append a new line to the `root_users.txt` file and then
      include lines that contain "nologin" in the `/etc/passwd` file.

          echo "" >> ~/root_users.txt
          grep nologin /etc/passwd >> ~/root_users.txt
      
      Verify the updated contents of the `root_users.txt` file.

          cat ~/root_users.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding input redirection 
    description: |
      Input redirection allows you to provide input to a command from a file instead of
      the keyboard. 

      Use `<` to redirect input from a file:

          sort < input.txt
    action: |
      Extract only the usernames from the `/etc/passwd` to a file in 
      your home directory.

          cut -d: -f1 /etc/passwd > ~/mypasswd.txt
      
      Use input redirection to sort the contents of the `~/mypasswd.txt` file.

          sort < ~/mypasswd.txt
      
      Combining input redirection with output redirection, you can save the sorted
      output to a new file named `~/sorted_passwd.txt`.

          sort < ~/mypasswd.txt > ~/sorted_passwd.txt

      Verify the results stored in the file.

          cat ~/sorted_passwd.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding stdin, stdout, and stderr
    description: |
      In the command line, there are three standard streams:
      
      - (0) `stdin`: Standard input (usually the keyboard).
      - (1) `stdout`: Standard output (usually the terminal).
      - (2) `stderr`: Standard error (used for error messages).
      
      You can also redirect these streams to files or other commands.
    action: |
      Use `ls` to list files in a directory and redirect the output to a file.
      
          ls /etc > ~/etc_files.txt

      Simulate an error by trying to list a non-existent directory
      and redirect the error message to a file named `~/error_log.txt`.

          ls /non_existent_directory 2> ~/error_log.txt
      
      Verify that the error message was saved in the `~/error_log.txt` file.

          cat ~/error_log.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Redirecting to the "/dev/null" device
    description: |
      The `/dev/null" device is a special file that discards all input.
      You can think of it as "The trash" or "The Void"

      It is commonly used to redirect errors when we want to ignore them 
      or remove them from the resulting output
    action: |
      Try running a find command of txt files starting from the root directory.

          find / -name "*.txt" 

      Notice, that many "permission denied" errors will appear because we 
      tried searching at the `/` directory, and many of the directories
      under it can only be accessed by the 'root' user.

      Ignore those errors by redirecting them to the trash.

          find / -name "*.txt" 2> /dev/null

      Notice, we used `stderr` channel `(2)` to the `/dev/null`
    verification: SKIP_CHECK
    exit_code: 0
    
  - name: Understanding the `tee` command
    description: |
      The `tee` command reads standard input and writes it to standard output
      and one or more files. It's often used with a pipe to capture the output
      of a command while also viewing it in the terminal.

      - `-a`: appends to the file instead of overwriting it.
    action: |
      1. Run `ls -l` and pipe the output to `tee` to save it to a file.
            ls -l | tee list_from_tee.txt

      2. Verify that the file was created
            ls -l list_from_tee.txt

      2. Check the contents of the `file_list.txt` file.
            cat list_from_tee.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the `cat` command
    description: |
      The `cat` command (concatenate) is used to display the contents of a file.
      It's one of the simplest and most-used commands for printing files on screen.
    action: |
      1. Create a simple text file:
            echo "Hello, World!" > hello.txt

      2. Use `cat` to display its content:
            cat hello.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the `sort` command
    description: |
      The `sort` command sorts lines of text

      Some common options:

      - `-r`: Reverse the sort order.
      - `-n`: Sort numerically.
    action: |
      1. Create a list of unsorted numbers:
            echo -e "5\n2\n8\n1\n3" > numbers.txt

      2. Print the list as is:
            cat numbers.txt

      3. Sort the numbers numerically:
            sort -n numbers.txt

      4. Sort the numbers in reverse order:
            sort -rn numbers.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the `uniq` command
    description: |
      The `uniq` command filters out duplicate lines from a file or standard input.
      It requires that the duplicate lines be adjacent, so it's
      often used with `sort`.
    action: |
      1. Create a list with duplicate lines:
            echo -e "apple\nbanana\napple\ncherry" > fruits.txt

      2. Print the list as is:
            cat fruits.txt

      2. Sort the file and then remove duplicates:
            sort fruits.txt | uniq
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the `wc` command
    description: |
      The `wc` command (word count) prints the number of lines, words, and
      bytes in a file. It is a simple tool for getting basic statistics
      about a file's content.

      Some common options:

      - `-l`: Count lines.
      - `-w`: Count words.
      - `-c`: Count bytes.
    action: |
      1. Create a simple text file:
            echo "This is a test file with some words." > test.txt

      2. Run `wc` to count the lines, words, and bytes:
            wc -l test.txt
            wc -w test.txt
            wc -c test.txt
      
      3. You can also do them all at once:
            wc test.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the `cut` command
    description: |
      The `cut` command is used to select and display specific fields from
      each line of a file. It's great for extracting data from structured
      text, like a CSV file.

      - `-f`: Specify the field to cut.
      - `-d`: Specify the delimiter.
    action: |
      1. Create a temporary file that is formatted as a CSV:
            echo "name,age,city" > users.csv
            echo "john,30,new york" >> users.csv
            echo "jane,25,london" >> users.csv

      2. Print the file as is:
            cat users.csv

      3. Use `cut` to display only the `name` field:
            cut -d',' -f1 users.csv

         Notice, we use the `,` comma as a delimitation character
         and requested the first field only.
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `awk` language - Print
    description: |
      `awk` is a powerful text processing tool. At its most basic, 
      can be used to print specific fields from a line, much like `cut`,
      but with more flexibility.

      `awk '{print $1, $3}'` prints the first and third fields.
    action: |
      1. Extract the `%Use` column from the `df -h` command:
            df -h | awk '{print $5}'

      2. Extract the First and the Fifth columns:
            df -h | awk '{print $1, $5}'
      
      By default, `awk` uses the space as field separator, but 
      we can change it using the `-F` option.

      3. Using the `users.csv` file from the previous example:
         Use `awk` to print the first field:
            awk -F',' '{print $1}' users.csv

         Notice that we use the `,` comma as a delimitation character.

      4. Use `awk` to print only the first and last columns:
            awk -F',' '{print $1, $3}' users.csv
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `awk` language - Arithmetic
    description: |
      `awk` can perform simple arithmetic operations on numeric fields.
    action: |
      1. Create a file with a list of numbers:
            echo -e "10\n20\n30\n40" > numbers.txt

      2. Print the list as is:
            cat numbers.txt

      3. Use `awk` to calculate the sum of the numbers:
            awk '{sum += $1} END {print sum}' numbers.txt
         
         Notice that the operation occurs within the quotes and receives
         the file as input. The operation is divided into two parts:
            - {sum += $1}       Loops through the values and sums them up.
            - END {print sum}   At the END of the loop, it prints the sum.

        Other available operations are:
          - sum: To perform addition
          - sub: To perform subtraction
          - mul: To perform multiplication
          - div: To perform division
          - mod: To perform modulus (remainder)          
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `awk` language - Concatenation
    description: |
      In `awk`, string concatenation is done by placing two strings next
      to each other.
    action: |
      1. Create a file with names and departments:
            echo -e "john dev\njane ops" > employees.txt

      2. Print the list as is:
            cat employees.txt

      2. Use `awk` to print a combined string for each employee:
            awk '{print "Employee: " $1 " is in department: " $2}' employees.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `awk` language - Built-in variables
    description: |
      `awk` has several built-in variables.
      
      - `NR`: The number of records (lines).
      - `NF`: The number of fields in the current record or line.
      - `$0`: The entire line
    action: |
      1. Create a multi-line file with a few fields:
            echo -e "1 2\n3 4 5\n6 7" > data2.txt

      2. Print the file as is:
            cat data2.txt

      3. Use `awk` to print the line number and number of fields for each line:
            awk '{print "Line " NR ": " NF " fields"}' data2.txt

      4. From the `free -h` extract the `Mem` line using grep and print the 
         last field formatted as "available memory: <value>"
            free -h | grep Mem | awk '{print "available memory: " $2}'
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `awk` language - printf
    description: |
      `printf` is a powerful function in `awk` for formatting output.
    action: |
      Use `printf` to create a formatted table from the `/etc/passwd` file only
      of users that can log in, printing only the username, and home directory.
    
          grep -v nologin /etc/passwd | awk -F':' '{printf "%-15s %-15s\n", $1, $6}'

      Notice: 
        - Used a reversed grep of "nologin" to get users who can log in.
        - Used the ":" character as a field separator
        - Taking fields $1 and $6 (username and home directory)
        - Used printf with the format `%-15s %-15s\n`, meaning:
              %   placement for value
              -   Left-align the output within the field
              15  Field width is 15 characters
              s   Print as a string
              \n  Newline character
      
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `sed` language - Replacing
    description: |
      `sed` (stream editor) is a text-editing utility that performs
      transformations on text. Its most common use is for
      performing find-and-replace operations.

          sed 's/old_string/new_string/g'

      Where:
        - `s` calls the substitute function
        - `g` calls the global function 
    action: |
      1. Create a simple text file:
            echo "The fox is fast." > fox.txt

      2. Use `sed` to replace "fox" with "rabbit":
            sed 's/fox/rabbit/' fox.txt

      3. Extract the login users from the `/etc/passwd` file:
            grep -v nologin /etc/passwd > login_users.txt
      
      4. Use sed to replace the ":" character with a blank space
            sed 's/:/ /g' login_users.txt

      5. Do it again without the `g` flag:
            sed 's/:/ /' login_users.txt

         Notice that only the first occurrence of each line 
         was affected if the global flag was not used.
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `sed` language - In file replacing
    description: |
      By default, `sed` prints its output to the terminal, leaving the original
      file unchanged. To edit a file in place, you must use the `-i` option.
    action: |
      1. Create a simple text file:
            echo "The quick brown fox." > sed_file.txt

      2. Use `sed` to replace "fox" with "bear" and save the change
         to the original file:
            sed -i 's/fox/bear/g' sed_file.txt
      
      3. Verify the change by viewing the file's content:
            cat sed_file.txt
    verification: SKIP_CHECK
    exit_code: 0

  - name: The `sed` language - Deleting
    description: |
      You can use `sed` to delete lines from a file.
      The `d` function is used to delete lines.
    action: |
      1. Create a file with multiple lines:
            echo -e "line1\nline2\nline3" > sed_delete.txt

      2. Print the file as is:
            cat sed_delete.txt

      3. Use `sed` to delete the second line:
            sed '2d' sed_delete.txt
      
      4. Do it again but in place:
            sed -i '2d' sed_delete.txt
      
      5. Verify the change by viewing the file's content:
            cat sed_delete.txt
    verification: SKIP_CHECK
    exit_code: 0

...